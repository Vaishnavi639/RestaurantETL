# restaurant_etl/parsers/llm_parser.py
"""
Robust LLM parser for menu extraction (AzureOpenAI).

Features:
- Conservative chunking (3500 chars)
- Retries with exponential backoff
- JSON safety/repair heuristics for unescaped/unterminated JSON from model
- Optional JSON Schema validation (if jsonschema installed)
- Flexible import for post-processing function name
"""

import os
import json
import time
import logging
from typing import Optional, List, Dict

from dotenv import load_dotenv
load_dotenv()

from restaurant_etl.models.menu_models import MenuItem, MenuData
from restaurant_etl.parsers.prompt_templates import SYSTEM_PROMPT, USER_PROMPT_TEMPLATE, AZURE_MENU_SCHEMA

# Postprocess import: support either function name used across versions
try:
    # preferred name used in some versions
    from restaurant_etl.parsers.postprocess import expand_and_normalize_items as postprocess_fn
except Exception:
    try:
        # alternate name used in other version
        from restaurant_etl.parsers.postprocess import postprocess_llm_items as postprocess_fn
    except Exception:
        # fallback: identity function (returns items as-is); will still validate later
        def postprocess_fn(items):
            return items

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def _safe_json_load_with_repair(raw: str) -> Dict:
    """
    Try to parse JSON. On failure, apply simple repairs:
    - Strip trailing garbage after final closing brace
    - Escape newlines/tabs inside strings (simple heuristic)
    - Replace Python None/True/False with JSON null/true/false
    - Attempt progressively simpler repairs before giving up
    """
    raw = raw.strip()

    # Quick sanity: if it's already a dict/list, return it
    if isinstance(raw, (dict, list)):
        return raw

    # 1) Trim trailing content after last top-level brace/bracket
    last_obj = raw.rfind("}")
    last_arr = raw.rfind("]")
    last_pos = max(last_obj, last_arr)
    if last_pos != -1 and last_pos < (len(raw) - 1):
        candidate = raw[: last_pos + 1]
    else:
        candidate = raw

    # Try direct parse first
    try:
        return json.loads(candidate)
    except json.JSONDecodeError as e:
        logger.debug(f"Direct json.loads failed: {e}")

    # 2) Replace common Python literals and unescaped control chars
    repaired = candidate.replace("\r", " ").replace("\t", " ")
    # Replace Python's None/True/False to JSON tokens (safe heuristic)
    repaired = repaired.replace("\n", "\\n")
    repaired = re_sub_python_literals(repaired)

    try:
        return json.loads(repaired)
    except Exception as e:
        logger.debug(f"Second json.loads attempt failed: {e}")

    # 3) Heuristic: remove unbalanced quotes by truncating at last quote pair
    try:
        # find last closing quote that seems to end a JSON string
        last_quote = repaired.rfind('"')
        if last_quote != -1:
            repaired2 = repaired[: last_quote + 1]
            return json.loads(repaired2)
    except Exception as e:
        logger.debug(f"Third json.loads attempt failed: {e}")

    # If all fails, raise explicit error with sample of raw for debugging
    snippet = (raw[:1000] + "...") if len(raw) > 1000 else raw
    raise ValueError(f"Failed to parse JSON from model response. Sample:\n{snippet}")


def re_sub_python_literals(s: str) -> str:
    """
    Replace Python-style None/True/False with JSON tokens, in a conservative manner.
    """
    # We avoid simple replace(None->null) everywhere because it can corrupt strings.
    # Do a cautious replace for common patterns: ': None' or ': True' etc.
    s = s.replace(": None", ": null")
    s = s.replace(":None", ":null")
    s = s.replace(": True", ": true")
    s = s.replace(": False", ": false")
    s = s.replace(":True", ":true")
    s = s.replace(":False", ":false")
    return s


class LLMMenuParser:
    def __init__(self):
        # Lazily import AzureOpenAI to avoid import issues at top level
        try:
            from openai import AzureOpenAI
        except Exception as e:
            raise ImportError("Azure OpenAI SDK not found. Install the 'openai' package compatible with AzureOpenAI.") from e

        self.api_key = os.getenv("AZURE_OPENAI_API_KEY")
        self.endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
        self.deployment = os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME")
        self.api_version = os.getenv("AZURE_OPENAI_API_VERSION", "2024-08-01-preview")

        if not all([self.api_key, self.endpoint, self.deployment]):
            raise ValueError("Missing Azure OpenAI credentials in .env

